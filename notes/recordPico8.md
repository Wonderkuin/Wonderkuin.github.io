# pico-8 精彩代码解析
### [原文 IndieNova](https://indienova.com/column/36)

---

### 1 植物生长

```lua
cls()
print("grow")
line(0,5,15,5,11)
memcpy(0,24576,384)
cls()
sspr(0,0,15,6,11,70,105,35)
::_::
x=rnd(128)
c=0
y=rnd(64)+64
u=x+rnd(2)-1
v=y-1
for a=u-1,u+1 do
  for b=v-1,v+1 do
    if (pget(a,b)%6>0)
      c+=1
  end
end
if(pget(x,y)%6>0 and (pget(u,v)==6 or rnd()<.1) and c<6)
  pset(u,v,3+c%2*8)
goto_
```

```
前六行是在屏幕下半部分打印 GROW
8-12行定义了5个变量
  c用来计数
  x在横坐标随机取值
  y在64-128范围内随机取值
    很明显这是在下半个屏幕中随机取坐标点，
    即GROW所在区域
  u随机取[x-1,x,x+1]在x值左中右3个值中随机
  v=y-1是y值上方的点
这样算法的意图就比较明显了，在显示范围内随机取点，在该点上方左中右方向上延伸
以模拟植物向上分叉生长的感觉
比如：u改成u=x使植物只能向上生长
v=y+1使像素点向下延伸

13-17行的两个嵌套for循环
将(u,v)附近的九宫格内的像素点遍历一遍
if (pget(a,b) % 6 > 0) c+=1
取其颜色值(0-15)与6取余，大于0则c加一
其实就是计算(u,v)附近的颜色非0,6的像素的数量c
这里背景色是黑色0，GROW是灰色6

第18行，根据三个判断将点(u,v)着色
pget(x, y) % 6 > 0
  (u,v)下方的点(x,y)不能是背景色0或者物体的颜色6
  也就是草不饿能从背景或者物体上长出，这里只能从底部绿色土地上长出。
pget(u, v) == 6 or rnd() < 0.1
  (u,v)的像素如果是字体颜色6，则可以着色，否则只有0.1的概率会着色
  这里模拟植物优先在字体表面生长，空白部位只有很少的草在增长。
c < 6
  (u,v)周围九宫格范围内的草的数量，如果大于6则不再生长，用于控制草的密度
最后根据 pset(u,v,3+c%2*8)密度用两种绿色进行着色。

在最后解释一下1-6行打印GROW的代码
2-3行在屏幕的左上角打印GROW并在字体下方加上绿色的下划线
第4行memcpy(0,24576,384)将屏幕内容所在的内存地址24576后的384bytes
复制到精灵内存地址0

pico8中，24576开始的内存存放的是屏幕中的像素颜色的信息，一个bytes8位可以存放
两个点，低4位和高4位分别存储一个点的颜色信息。这也是pico8只能有2的4次方，16种颜色
的原因。
那384 = 128 * 6 / 2 正好是屏幕中打印的GROW所在的前6行，将打印的GROW拷贝到存放精灵的地址中，再使用sspr函数
将精灵放大到显示屏幕的中心。

这样复杂的操作仅仅是为了打印一个字号比较大的GROW而已，因为自带的print函数不能设置字号。
这样做会把pico8中精灵编辑器中前六行的内容都覆盖掉，所以直接在精灵编辑器中编辑再显示在屏幕中是个更好的选择。
这里作者肯定是为了简便才使用这种直接的打字方式。

总结
这种随机遍历每个像素点来实现的特效会消耗大量cpu，用在游戏中的话，还需要做相应的简化。
虽然这种技巧看起来很难用到游戏里， 但是这也是可以逐像素操作的pico8的魅力
当然在其他游戏引擎中， 可以用像素着色器Shader更有效率的实现这种算法。
作者用u,v作为变量名，应该也是Shader写法的影响
```

### 2 神奇漩涡

```lua
p={130,141,2,136,8,137,142,9}
for i=1,8 do
  pal(i-1,p[i],1)
end
::_::
x=rnd(128)
y=rnd(128)
d=sqrt((x-64)^2+(y-64)-t()*4
a=atan2(y-64,x-64)*16
pset(x,y,(a+d/4)%8)
goto_
```

```
1-4行代码是调色板映射代码，用来实现渐变的颜色。
我们知道pico8只有16色，很难配合出渐变效果
这里作者用到pico8隐藏的调色板
变量p中的 130 141 136 137 142都是隐藏调色板的色号

6-9行定义了4个参数
x,y
  在屏幕范围内随机取值
d
  是取的点(x,y)相对于(64,64)即中心点的距离
  后面的t()*4是为了使距离根据运行时间改变
a
  是取的点(x,y)相对于中心点的角度
  pico8中atan2的返回值是0-1
  对应着0度到360度，后面的*16将a的值变成了0-16

第10行
  根据d和a的值将对应颜色填充到x,y
  如果 pset(x,y,a%8)只用a来计算
    会将屏幕按照点的到中间点的角度分隔成16份
    因为a的取值是0-16，相当于把屏幕中的点映射到16个区域
  如果 pset(x,y,(d/4)%8)
    会一圈一圈的画圆
    d是点到中心的距离，相同距离的圆形区域被填充同一个颜色
  如果 pset(x,y,(a+d/4)%8)
    把角度和距离加起来的时候，神奇的图像出现了，是漩涡
    角度a必须与8的倍数相乘才可以对齐，很神奇
    atan2(y-64,x-64)*8    一个漩
    atan2(y-64,x-64)*16   两个漩
    atan2(y-64,x-64)*24   三个漩
```

### 3 触手

```lua
c={10,9,8,2,1,0}
fillp(0xa5a5)
function _draw()
  for i=24576, 32767 do
    poke(i,peek(i)/2)
  end
  for z=6,1,-.1 do
    for b=0,7 do
      b=b/8+sin(z/8+t()/4)/30
      k=19-sin((6-z)/20)*40*(.5+sin(t()/2+z/9+b*2)/2)
      circfill(64+cos(b)*k,64+sin(b)*k,z*2.3,c[flr(z)]+c[flr(z+.5)]*16)
    end
  end
end
```

```
1-2行
  c是触手的颜色，顶部到底部由明到暗
  fillp是填充样式 点阵图样填充，有种渐变的效果
4-6行
  是残影效果，这里没用cls清空画布
  直接将屏幕内存中的数值每帧减半，最终将为0透明
  来实现透明效果
10-11行
  两个嵌套循环
  外层的z表示，每个触手的层数，内层b表示触手的数量 8个
  单个触手是由下至上，大小递减，颜色逐渐变亮的圆组成
  z表示圆的位置，相当于z轴的坐标，从6-1共有60层
9行
  b/8将八只触手映射到0-1 pico8中三角函数的参数取值0-1代表着0-360度
  在第11行 circlefill圆的绘制函数中，圆b的位置x,y = 64+cos(b)*k, 64+sin(b)*k
  其中原点是屏幕的中心点64,64;角度b为每个触手映射的角度，k为圆至屏幕中心的距离
  三角函数 y=cos(b)*k x=sin(b)*k
10行
  计算每个圆至屏幕中心的距离k，我们先把圆的角度b从中去掉看下结果。
  k=19-sin((6-z)/20)*40*(.5+sin(t()/2+z/9)/2)
  每个触手的动作都一样了
  将圆的z轴左边z映射到至中心的距离k，通过sin的映射使得，距离k根据z呈现正弦波的形状
  最后把角度b加回去
  k=19-sin((6-z)/20)*40*(.5+sin(t()/2+z/9+b*2)/2)
  使得不同的触手在波形上拥有不同的位置
11行
  circlefill画圆，其中圆的半径根据z轴距离变化，z*2.3
  圆的颜色 c[flr(z)]+c[flr(z+.5)]*16 是两个颜色相加，利用高低位的不同颜色
  再配合第2行的fillp实现两种颜色的填充图样

最后补充一下fillp的用法，pico8中 用一个4x4的图来填充circ() circfill() rect() rectfill() pset() line()
等函数画的图形

.----------------------.
|32768|16384| 8192| 4096|
|-----|-----|-----|-----|
| 2048| 1024| 512 | 256 |
|-----|-----|-----|-----|
| 128 |  64 |  32 |  16 |
|-----|-----|-----|-----|
|  8  |  4  |  2  |  1  |
'-----|-----|-----|-----'
Fillp(4+8+64+128+256+512+4096+8192) 会创建一个棋盘图案

16个像素点用上图表格里的数字代表，如果想让某个点不着色就将点对应的数值累加，将最终得到的值传给fillp
比如只让对角线 32768, 1024, 32, 1 没有颜色 fillp(32768+1024+32+1)

circfill(64, 64, 32, 7)
circfill(64, 64, 32, 7+8*16)
也可以7+8*16指定第二个颜色
```

### 4 摆动

```lua
for i=0,11 do
  pal(i,({135,10,9,137,8,136,2,130,128})[i+1],1)
end
function _draw()
  srand(3)
  rectfill(0,0,127,40,0)
  for y=52,170,2 do
    k=y/19-2
    x=y*44%138-4
    h=40+rnd(20)
    for i=-20,20 do
      line(x+i*h/70,y,x+sin(t()/4+x/500+y/300)/7*h,y-h,i>0 and k+2 or k)
    end
  end
end
```

```
1-3行
  将调色板的颜色映射，这里用到了第二块调色板的颜色，更好的表示渐变。
  关于第二块调色板的内容，在解析2里有说明
5行
  初始随机种子，在计算树木高度的时候，详细解释为什么每次绘制要初始随机数
6行
  画背景，cls()代替手动绘制背景，可以更好的测试
7行
  循环得到y y的值是树y轴位置，从52-170 每两个树之间差2
8行
  k用来将树按照y的值的顺序，映射到调色板的色值，实现近景到远景的颜色渐变
9行
  计算树的x坐标，根据y轴坐标的倍数与138取余，就把树木限制在0-138的范围内
  一排排码好
10行
  计算树木的高度h，这里每棵树的高度是随机的，但是每帧绘制的时候，同一棵树高度不变
  也就是每一帧绘制的时候 rnd(20) 会得到同一个随机值，这就得益于第5行，绘制开始时
  重新初始化随机种子，使得每一帧获得的随机数是一致的
11-13行
  绘制一棵树，pico8没有直接绘制三角形的函数，这里用40根线段拼成了一个三角形
  我们看简化的代码：
  line(x+i,y,x,y-h,i>0 and k+2 or k)
  i 值 (-20,20)是三角形底边的x轴偏移量
  从选段起点(x-20,y)终点(x,y-h) 到 起点(x+20,y)终点(x,y-h)
  共画了40根线段组成了三角形，三角形底边宽40
  line(x+i*h/70,x+sin(t()/4+x/500+y/300)/7*h,y-h,i>0 and k+2 or k)
  原代码计算起点时将偏移量i乘以树木的高度h/70用来表示，矮的树木拥有更窄的底边
  计算重点时，树尖的x坐标根据时间，取正弦值，用来模拟来回摆动的效果。且越矮的树木
  摆动幅度越低。最后根据偏移量i来决定颜色 i<0为树木左半边，i>0为树木右半边
```