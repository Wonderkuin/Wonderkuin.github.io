# 面向对象的游戏开发
#### Object-Oriented Game Development

---

# 第一章 简介

```
编程 艺术 设计 是游戏开发过程中的三位一体
```

---


# 第二章 游戏开发过程

```
2.1 开发原则

适用范围
	所有的原则或原理都有其适用范围，无论它们是如何正确，都只能在特定的场合发挥作用
逐步求精
	从简单开始，逐步求精，直至满足需求
统计结论
	不要只准备一种解决手段应付关键性工作
避免重复犯错
	如果某个方法无法奏效，则用有用的方法替代它。
	承认错误，从失败中总结经验教训，避免下次再犯同样的错误
善用成功经验
	如果某个方法奏效，则在今后的工作中善用这个方法
避免简单重复
	不要重复犯错，更不要简单重复
全面考虑问题
	不要固执己见，要全面考虑各个方案的优缺点


2.2 现实的约束

金钱的压力
	游戏开发投入很高，对于独立开发者，情况更糟。
黑客宪章
	软件的每个代码片断都有与之相关的优先级。
	在书写每一行代码时，程序员都必须做出取舍。
	程序员的选择取决于要完成的项目的需求。
	那么游戏的优先级是什么，这不能一概而论。
	速度 控制 鲁棒性 商业现实
	黑客宪章把游戏开发当成一种即兴的游戏，这与商业游戏开发的现实不相适应。
游戏开发的独特性
	自由的设计
		核心特性 必须特性 期待特性
		具备灵活的特性空间，这种自由是其他软件开发过程中所没有的
	启发式内容
		很难在游戏完成前预知它的内容和感觉。
		原型开发能够确定游戏的生存能力，却不能提高游戏的可玩性。
		仅仅因为游戏的一些内容导致游戏无法控制或无趣，可以删除它们。
		调整游戏的核心内容以满足预期中玩家的需求。
	美工元素
		外观漂亮的软件和游戏比起来简直是班门弄斧。
		艺术创作对游戏编程的影响也是巨大的。
	控制方法
		UI十分复杂
	降低复杂性
		黑客宪章带来的好处是：它们提倡在低端机器上编写复杂，极尽能事的算法。
		例如：在33MHz CPU上写一个真实感强的赛车模拟游戏很了不起。
		尽量降低游戏复杂性同时又让玩家沉浸其中，对游戏开发来说是一个挑战。
	总结
		黑客宪章的本质是，认为游戏开发与一般的软件开发不同
		这种思维是谬论和废话，黑客宪章必须被彻底抛弃。
		有效的代码可以改进程序性能，有效的开发过程可以减少所需的时间和金钱。
```

---

# 第三章 游戏开发中的软件工程

```
可以做出漂亮Demo的人不一定适合从事游戏开发。
必须明确定义职业游戏程序员的必须掌握的技能。

建立软件标准
组内检查
双人任务
代码重用
```

```c++
//3.3.7 地狱的诅咒
//代码的相关性越多，其可重用价值就越少，相关性是可传递的
//相关性少的代码，更容易被使用，可读性更好

//强关联
//如果A.hpp 必须包含 B.hpp才能编译成功，A与B存在强关联
//B.hpp
#include "A.hpp"
class B {
	A m_A;
};

//硬关联
//如果A与B之间有关联，且B与A之间有强关联，那么A与B之间就存在着硬关联
//B.hpp
#include "A.hpp"
class B {
public:
	B();
	B(int i);
private:
	A m_A;
};
//A.hpp
class B;
class A {
public:
	A(int i);
	B Foo();
private:
	int m_iData;
};
//A.cpp
#include "A.hpp"
#include "B.hpp"
B A::Foo() {
	return ( B(m_iData) );
}

//弱关联
//如果A.cpp中必须包含B.hpp文件才能编译通过，那么A与B之间存在弱关联
//B.hpp
class B {
public:
	B();
private:
};
//A.hpp
class B;
class A {
public:
	A(int i);
	B Foo();
private:
	int m_iData;
};
//A.cpp
#include "A.hpp"
#include "B.hpp"
B A::Foo() {
	return ( B(m_iData) );
}

//软关联
//如果A只使用了B的指针或引用，那么A与B之间存在软关联
//A.hpp
class B;
class A {
public:
	A( B* pB);
private:
	B* m_pB;
};

// 关联程度 硬关联》强关联》弱关联》软关联

// 降低关联度的方法
// 如果存在硬关联，可以降为强关联
// 但有时需要的正是硬关联，例如：
//     开发者需要将两个类之间的消息传递加以优化。
// 因此并不是所有关联都要降低。
// 但必须是硬关联的情况很少见。如果出现了硬关联，必须审视这个设计

// 有的时候，一些关联完全没必要
// 例如在一个文件中加入了一个根本不需要的头文件。
// 如果只是需要一个类的指针或引用，或者函数返回的是一个类的指针或引用，
// 那么完全没必要加入那个类的头文件，用一个预声明就足够了。
// 这不仅可以降低关联性，而且也使编译更快。
class MyClass;
void Foo(MyClass *pClass);
void Foo(MyClass ^aClass);
void Foo(MyClass aClass);
MyClass Foo();
typedef std::stack<MyClass> MyList;

// 强度降低
// 强度降低的思想是将一个强绑定用一个弱绑定代替
// 继承是最强的绑定，它需要声明一个继承的类实现父类的功能，这种关系一旦确立就无法改变。
// 但这里存在公有继承，保护继承和私有继承之间的区别。
#include "Base.hpp"

class Derived : public Base
{
};
// 另一个较强的绑定是拥有，它比继承的强度要低，但与私有继承很相似
#include "Owned.hpp"

class Thing
{
public:
private:
	Owned m_Owned;
};
// 最弱的绑定是引用，它不需要添加头文件，只需要预声明被引出的类。
// C++中有两种类型的引用。一种是引用，一种是指针。
// 引用的引用要求更高，引用一旦确定，就不能被更改。
class Referred;

class HasReference
{
private:
	Referred & m_pInstance;
public:
	HasReference( Referred &aThing )
		: m_rInstance(aThing)
	{
	}
};
// 指针是最自由的绑定类型。也最难管理，它可以随意地被重新赋值
class Referred;

class HasPointer
{
private:
	Referred * m_pInstance;
public:
	HasRefreence(Referred *pThing)
		: m_pInstance(pThing)
	{
	}
};

// 为了使组件更加独立，要降低其绑定的程度。一种可行的方法是用指针替换拥有：
#include "Owned.hpp"

class Thing
{
private:
	Owned m_Owned;
};

// to
class Owned;

class Thing
{
private:
	Owned * m_Owned;
}
// 这种方式带来两个缺点，一是性能可能会降低，二是需要对内存做动态管理
// 关联的强度与是否包含头文件之间存在着紧密联系
// 因此，降低关联也会加快编译速度
// 不过，在决定对代码做大手术并大量引入指针之前，请记住：
//     如果要在类中使用公有或者保护类型的内联函数，那么需要引入一些无关的头文件
//         私有的内联函数最好放在cpp中
//     弱关联并不意味着更好的代码，有时候设计需要更高的关联


// 重构
// 完全避免相关性可能不切实际，因此可以将相关性的部分放到一个类的子类中，以提高重用性
// (Object)-Animation->(Animation)
```

---